# Story 1.3: Component Token Architecture

## Status
Draft

## Story

**As a** component developer,
**I want** component-specific design tokens that create a clean API for theming individual components,
**so that** I can build components that automatically respond to theme changes without hardcoded values.

## Acceptance Criteria

1. **Component Token Files:** Individual token files created for button, card, and form components with component-specific variables
2. **Token Inheritance:** Component tokens properly reference semantic tokens rather than primitive values directly
3. **Component Integration:** Existing ccmButton component updated to use component tokens via CSS custom properties
4. **Theme Responsiveness:** Component tokens automatically inherit theme changes when semantic tokens are modified
5. **Token Isolation:** Component-specific tokens are scoped to avoid naming conflicts with other components

## Tasks / Subtasks

- [ ] Create component token directory structure (AC: 1)
  - [ ] Create `/public/css/tokens/component/` directory
  - [ ] Set up import chain in main `styles.css` with proper layer assignment

- [ ] Implement button component tokens (AC: 1, 2, 5)
  - [ ] Create `/public/css/tokens/component/button.css` file
  - [ ] Define button-specific semantic token references (not primitive values)
  - [ ] Use scoped naming pattern (`--button-*`) to avoid conflicts
  - [ ] Include color, spacing, typography, and interaction tokens
  - [ ] Reference semantic tokens from story 1.2 (semantic layer)

- [ ] Implement card component tokens (AC: 1, 2, 5)
  - [ ] Create `/public/css/tokens/component/card.css` file
  - [ ] Define card-specific semantic token references
  - [ ] Use scoped naming pattern (`--card-*`) to avoid conflicts
  - [ ] Include surface, border, shadow, and spacing tokens

- [ ] Implement form component tokens (AC: 1, 2, 5)
  - [ ] Create `/public/css/tokens/component/form.css` file
  - [ ] Define form-specific semantic token references  
  - [ ] Use scoped naming pattern (`--form-*`, `--input-*`, `--label-*`) to avoid conflicts
  - [ ] Include input styling, validation state, and accessibility tokens

- [ ] Update ccmButton component to use component tokens (AC: 3)
  - [ ] Replace hardcoded HSL references with button component tokens
  - [ ] Update button variants to use semantic color tokens
  - [ ] Ensure all button size and spacing uses token references
  - [ ] Maintain existing component API and behavior

- [ ] Validate theme responsiveness (AC: 4)
  - [ ] Test button component responds to semantic token changes
  - [ ] Verify card component inherits theme modifications
  - [ ] Check form components reflect semantic token updates
  - [ ] Test token cascade from semantic → component layers

- [ ] Test token isolation and prevent conflicts (AC: 5)
  - [ ] Verify no naming conflicts between component token files
  - [ ] Test component tokens don't leak into other components
  - [ ] Validate scoped naming patterns work correctly
  - [ ] Ensure tokens can be overridden at component level if needed

## Dev Notes

### Previous Story Insights
[Source: Story 1.1 Implementation Context]

**Token Hierarchy Foundation:**
- Three-tier token architecture established: primitive → semantic → component
- New `/public/css/tokens/` directory structure created with subdirectories
- CSS layers methodology with specific layer order: reset, defaults, components, utils, overrides
- PostCSS processing pipeline handles token imports and cascade

**Critical Dependencies:**
- Story 1.2 (Semantic Token Layer) must be completed first to provide semantic token references
- Component tokens MUST reference semantic tokens, never primitive tokens directly
- All token imports must use `layer(defaults)` for CSS cascade consistency

### CSS Architecture Context
[Source: docs/ui-architecture.md#css-layer-architecture]

**CSS Layers Methodology:**
- Layer hierarchy: reset → defaults → components → utils → overrides
- All token imports use `@import "file.css" layer(defaults)` syntax
- Component tokens belong in `defaults` layer but scope to specific components
- PostCSS processing handles modern CSS features with fallbacks

**Existing Component Token Patterns:**
[Source: components/ccmButton.vue analysis]
- Current button uses `--_button-*` naming pattern for local component variables
- Existing patterns: `--_button-color`, `--_button-hsl`, `--_button-padding-block`
- Uses CSS custom property inheritance with fallbacks
- Supports color, size, and variant customization through CSS properties

### Token Architecture Requirements
[Source: Epic 1.3 Definition + Architecture Analysis]

**Component Token Structure:**
- **Button Tokens**: Colors, sizes, spacing, borders, typography, interaction states
- **Card Tokens**: Surface colors, borders, shadows, spacing, corner radius
- **Form Tokens**: Input styling, label formatting, validation states, focus indicators

**Token Naming Convention:**
- Pattern: `--{component}-{property}-{variant?}`
- Examples: `--button-bg-primary`, `--card-shadow-elevated`, `--input-border-error`
- Scoped to component to prevent conflicts between components

**Semantic Token References:**
- Component tokens MUST reference semantic tokens: `--button-bg-primary: var(--semantic-bg-primary)`
- NEVER reference primitive tokens directly: ❌ `--button-bg: var(--primary-hsl)`
- Chain inheritance: primitive → semantic → component → local overrides

### File Locations and Import Chain
[Source: docs/ui-architecture.md#project-structure + Story 1.1 Context]

**Component Token Files:**
- `/public/css/tokens/component/button.css` - Button-specific tokens
- `/public/css/tokens/component/card.css` - Card-specific tokens  
- `/public/css/tokens/component/form.css` - Form-specific tokens

**Import Chain Updates:**
- Update `/public/css/styles.css` to import component token files
- Place imports after semantic tokens, before component styles
- Use `@import "tokens/component/[name].css" layer(defaults);` syntax

**ccmButton Integration:**
- Located at `/components/ccmButton.vue`
- Update existing `--_button-*` variables to reference component tokens
- Maintain existing component API and prop structure
- Replace hardcoded HSL values with component token references

### Technical Constraints
[Source: docs/ui-architecture.md#architecture-decisions + Current Analysis]

**CSS Layer Integration:**
- Component tokens must import into `defaults` layer
- Maintain existing cascade order and specificity rules
- No `!important` usage allowed - leverage proper layer cascade

**Token Inheritance Rules:**
- Component tokens → Semantic tokens → Primitive tokens (never skip levels)
- Support local component overrides at the component level
- Fallback values for older browser support

**Component API Preservation:**
- Existing ccmButton props and behavior must remain unchanged
- Color, size, and variant props continue to work as expected
- No breaking changes to component usage patterns

### Testing Requirements
[Source: docs/ui-architecture.md#testing-approach]

**Component Testing:**
- Test ccmButton visual consistency after token migration
- Verify all component variants work with new token system
- Test responsive behavior across breakpoints (321px, 769px)
- Validate component isolation - no token conflicts between components

**Token Validation Testing:**
- Verify component tokens correctly reference semantic tokens
- Test theme switching affects all components through token inheritance
- Validate no circular token references exist in the system
- Check CSS custom property cascade works correctly

**Testing Frameworks:**
- Vitest and @nuxt/test-utils configured for component testing
- No specific CSS testing patterns defined - rely on visual verification
- Test existing components continue to render without visual changes

### Project Structure Notes

Current `/public/css/` structure aligns with component token requirements:
- Existing `/public/css/vars/` contains current color and spacing tokens
- New `/public/css/tokens/component/` will house component-specific tokens
- CSS layer import chain maintains established cascade methodology
- No structural conflicts between Epic requirements and existing patterns

## Testing

### Testing Standards
[Source: docs/ui-architecture.md#component-standards + Testing Configuration]

**Test File Locations:**
- Component tests in `/tests/components/` directory (if created)
- Follow Vitest + Vue Test Utils patterns from architecture template

**Testing Frameworks:**
- Vitest configured as primary testing framework
- @nuxt/test-utils for Nuxt-specific component testing
- Vue Test Utils for component isolation testing

**Testing Requirements for This Story:**
- Visual regression testing of ccmButton after token migration
- Component variant testing (primary, secondary, ghost, link) 
- Size testing (s, m, l, xl) with new token system
- Color testing (base, primary, secondary, tertiary, accent) via tokens
- Theme switching validation - components respond to semantic token changes
- Token isolation testing - verify no cross-component token conflicts

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|  
| 2025-09-04 | 1.0 | Initial story creation with full context | Bob (Scrum Master) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*