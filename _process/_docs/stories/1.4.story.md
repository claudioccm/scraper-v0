# Story 1.4: Theme Switching Infrastructure

## Status
Draft

## Story

**As a** brand manager testing theme customization,
**I want** the ability to switch between different brand themes at runtime,
**so that** I can preview and compare different visual treatments without rebuilding the application.

## Acceptance Criteria

1. **Theme CSS Generation:** System generates theme-specific CSS files with semantic token overrides
2. **Runtime Theme Switching:** JavaScript utility enables switching themes by updating CSS custom properties
3. **Theme Persistence:** Selected theme persists across page reloads using localStorage
4. **Default Theme Structure:** Complete default theme file demonstrates all semantic token assignments
5. **Theme Validation:** System validates theme completeness and warns about missing token definitions

## Tasks / Subtasks

- [ ] Create theme CSS generation system (AC: 1, 4)
  - [ ] Create `/public/css/themes/` directory structure
  - [ ] Create `/public/css/themes/default.css` with complete semantic token assignments
  - [ ] Create example `/public/css/themes/dark.css` theme with semantic token overrides
  - [ ] Create example `/public/css/themes/brand-a.css` theme demonstrating brand customization
  - [ ] Integrate theme CSS files with existing CSS layer system (defaults layer)
  - [ ] Document theme file structure and semantic token override patterns

- [ ] Build JavaScript theme switching utility (AC: 2, 5)
  - [ ] Create `utils/themeManager.ts` with theme switching logic
  - [ ] Implement CSS custom property override functionality using document root
  - [ ] Build theme validation system to check for missing token definitions
  - [ ] Create utility functions for loading and applying theme CSS files
  - [ ] Implement error handling for invalid or incomplete themes
  - [ ] Add TypeScript interfaces for theme definitions

- [ ] Implement Pinia store for theme state management (AC: 3)
  - [ ] Create `stores/theme.ts` following established store patterns
  - [ ] Implement theme persistence using localStorage with SSR-safe initialization
  - [ ] Add reactive theme state management with computed getters
  - [ ] Implement theme switching actions with optimistic updates
  - [ ] Create theme validation actions and error state management
  - [ ] Export proper TypeScript interfaces for theme store usage

- [ ] Create theme switching composable (AC: 2, 3)
  - [ ] Create `composables/useTheme.ts` for component-level theme access
  - [ ] Expose reactive theme state and switching functions to components
  - [ ] Implement client-side theme application on mount
  - [ ] Add theme validation helpers for component usage
  - [ ] Handle SSR compatibility with theme switching
  - [ ] Document composable API and usage patterns

- [ ] Integrate with existing CSS architecture (AC: 1, 2)
  - [ ] Update `/public/css/styles.css` to import default theme
  - [ ] Ensure theme CSS loads after semantic tokens but before components
  - [ ] Test theme switching with existing components (ccmButton, ccmMasterGrid)
  - [ ] Validate theme overrides work correctly with CSS custom property cascade
  - [ ] Test responsive behavior with theme switching
  - [ ] Verify accessibility compliance across all themes

- [ ] Build theme validation and testing system (AC: 5)
  - [ ] Create theme completeness validation functions
  - [ ] Implement missing token detection and warning system
  - [ ] Add runtime theme integrity checks
  - [ ] Create development-mode theme debugging utilities
  - [ ] Test theme switching performance and memory usage
  - [ ] Validate theme persistence across browser sessions

## Dev Notes

### Architecture Context from Previous Stories
[Source: Stories 1.1, 1.2 Implementation Context]

**Key Insights from Previous Stories:**
- **Story 1.1:** Primitive token foundation established at `/public/css/tokens/primitives/`
- **Story 1.2:** Semantic token layer created at `/public/css/tokens/semantic/` (assumption: completed)
- CSS Layers methodology: reset → defaults → components → utils → overrides
- Existing CSS custom property system ready for theme overrides
- HSL color values and Utopia spacing scales provide primitive foundation for themes

### State Management Architecture
[Source: docs/ui-architecture/5-state-management.md#enhanced-state-management-template]

**Pinia Store Patterns:**
- **Composition API Stores:** Use `defineStore` with setup syntax for theme store
- **TypeScript First:** Full type safety with interfaces for theme definitions
- **SSR-Safe Initialization:** Handle client-side localStorage without SSR conflicts
- **Auto-persistence:** Automatic localStorage syncing for theme preferences
- **Readonly State:** Expose readonly refs to prevent direct mutation
- **Computed Getters:** Reactive derived state for current theme properties

**Store Structure Template:**
```typescript
// Expected pattern for stores/theme.ts
interface ThemeState {
  currentTheme: string
  availableThemes: string[]
  isLoading: boolean
  error: string | null
}

// Store template with localStorage persistence
const useThemeStore = defineStore('theme', () => {
  // State management with SSR-safe initialization
  // Auto-sync with localStorage using watchEffect
  // Actions for theme switching with validation
})
```

### Theme System Architecture
[Source: CSS Layer System Analysis]

**Theme CSS File Structure:**
```
public/css/themes/
├── default.css          # Complete semantic token assignments
├── dark.css            # Dark theme with semantic token overrides
├── brand-a.css         # Custom brand theme example
└── [future-themes].css # Additional brand themes
```

**CSS Layer Integration:**
- Theme CSS files import into `defaults` layer after semantic tokens
- Theme files contain only semantic token overrides, not primitive values
- Proper cascade order: primitives → semantics → themes → components

### JavaScript Theme Switching Approach
[Source: docs/ui-architecture/11-frontend-developer-standards.md#nuxt-3-specific-rules]

**Client-Side Requirements:**
- **SSR Compatibility:** Use `process.client` checks for DOM manipulation
- **CSS Custom Properties:** Update document root `:root` variables dynamically
- **Auto-imports:** Leverage Nuxt's auto-import for composables and utilities
- **TypeScript:** Full type safety for theme definitions and switching logic

**Theme Manager Utility Pattern:**
```typescript
// utils/themeManager.ts expected structure
interface ThemeDefinition {
  name: string
  tokens: Record<string, string>
  isComplete: boolean
}

// Functions for:
// - loadThemeCSS(themeName: string)
// - applyThemeTokens(tokens: Record<string, string>)
// - validateTheme(theme: ThemeDefinition)
// - switchTheme(themeName: string)
```

### CSS Custom Properties Override System
[Source: Existing CSS Architecture Analysis]

**Current Token Structure (from previous stories):**
- **Primitive Tokens:** Raw HSL values in `/public/css/tokens/primitives/`
- **Semantic Tokens:** Brand and system colors in `/public/css/tokens/semantic/`
- **CSS Custom Properties:** `:root` level variables ready for runtime override

**Theme Override Strategy:**
- Themes override semantic tokens only (never primitive tokens directly)
- Use CSS custom property inheritance for theme application
- Maintain existing component integration through semantic token references

### File Locations and Naming Patterns
[Source: docs/ui-architecture/3-project-structure.md#key-architecture-decisions]

**New Files to Create:**
- **Theme Store:** `stores/theme.ts` (Pinia store, auto-imported)
- **Theme Composable:** `composables/useTheme.ts` (auto-imported)
- **Theme Manager:** `utils/themeManager.ts` (auto-imported utility)
- **Theme CSS Files:** `/public/css/themes/` directory with theme-specific CSS
- **Theme Types:** `types/theme.ts` (TypeScript interfaces)

**Integration Points:**
- **Main CSS:** Update `/public/css/styles.css` to import default theme
- **Existing Components:** Test with ccmButton, ccmMasterGrid for theme responsiveness
- **Layout Integration:** Default layout should support theme switching

### Testing Requirements
[Source: docs/ui-architecture/9-testing-requirements.md#testing-best-practices]

**Testing Strategy for Theme Switching:**
- **Unit Tests:** Theme manager utility functions and validation logic
- **Component Tests:** Theme store actions and composable behavior
- **Integration Tests:** Theme switching across component hierarchy
- **Visual Tests:** Theme application and CSS custom property updates
- **Performance Tests:** Theme switching speed and memory usage
- **Accessibility Tests:** Contrast ratios and user preference respect across themes

**Testing Frameworks:**
- Vitest with @nuxt/test-utils for component and composable testing
- Vue Test Utils for store testing with proper Pinia setup
- Manual browser testing for localStorage persistence and visual validation

### Technical Constraints
[Source: docs/ui-architecture/11-frontend-developer-standards.md#critical-coding-rules]

**Nuxt 3 Specific Requirements:**
- **No `document` access without `process.client` check** - Critical for SSR compatibility
- **Use auto-imports** - No manual Vue imports, leverage Nuxt's auto-import system
- **Composition API only** - No Options API patterns, use `<script setup>` syntax
- **TypeScript first** - All interfaces and proper type definitions required

**CSS Layer Rules:**
- **Never bypass layer system** - All theme CSS must use layer methodology
- **CSS custom properties only** - No direct style manipulation, use CSS variables
- **Accessibility compliance** - Respect user preferences (dark mode, contrast)

**Performance Requirements:**
- **Minimal theme switching delay** - Optimize CSS custom property updates
- **Memory management** - Proper cleanup of theme resources
- **localStorage efficiency** - Minimal data persistence for theme state

### Project Structure Alignment
[Source: Project Analysis and Architecture Integration]

**Directory Structure Integration:**
```
ccm-website-7/
├── stores/              # Theme store (to be created)
├── composables/         # Theme composable (to be created) 
├── utils/              # Theme manager utility (existing directory)
├── types/              # Theme TypeScript definitions (existing directory)
└── public/css/
    ├── tokens/         # Existing primitive and semantic tokens
    ├── themes/         # New theme CSS files directory
    └── styles.css      # Main CSS with theme imports (to be updated)
```

**No Conflicts Identified:**
- Theme system integrates cleanly with existing CSS architecture
- Pinia store follows established patterns from architecture documentation
- Auto-import system supports composables and utilities as designed
- TypeScript integration aligns with existing type definition patterns

## Testing

### Testing Standards
[Source: docs/ui-architecture/9-testing-requirements.md#component-test-template]

**Test File Locations:**
- **Store Tests:** `tests/stores/theme.test.ts` using Vitest with Pinia testing utilities
- **Composable Tests:** `tests/composables/useTheme.test.ts` with @nuxt/test-utils
- **Utility Tests:** `tests/utils/themeManager.test.ts` for theme management functions
- **Integration Tests:** `tests/integration/theme-switching.test.ts` for end-to-end theme functionality

**Testing Requirements for This Story:**
- **Theme Store Testing:** State management, persistence, and action validation
- **Theme Switching Testing:** Runtime theme application and CSS property updates
- **Theme Validation Testing:** Completeness checks and error handling
- **Component Integration Testing:** Theme switching with existing components
- **Browser Persistence Testing:** localStorage functionality and SSR compatibility
- **Performance Testing:** Theme switching speed and resource management
- **Accessibility Testing:** Theme compliance with WCAG standards and user preferences

**Testing Configuration:**
- Use Vitest environment with Nuxt testing utilities
- Mock localStorage for SSR-safe testing
- Test theme switching without actual DOM manipulation in unit tests
- Integration tests validate actual CSS custom property updates

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|  
| 2025-09-04 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-09-04 | 1.1 | Story approved after validation | Bob (Scrum Master) |
| 2025=09-03 | 1.2 | Story back to draft by Claudio (User) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*